package ch.so.agi.simi.web.beans.filetransfer;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Assertions;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.Random;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class StyleStorageBeanTest {

    @Test
    public void uploadQmlOnly_Success(){
        StyleStorageBean trafo = new StyleStorageBean();
        StyleDbContent dbContent = trafo.transformFileToFields(createQmlContent(new int[]{2,18}), new int[]{2,18});

        assertTrue(
                dbContent.getQmlContent().contains("<qgis"),
                "db qml content must contain therm '<qgis'"
        );
    }

    @Test
    public void uploadQmlOnly_Exception_TooYoungMajorVersion(){

        StyleStorageBean trafo = new StyleStorageBean();

        Exception ex = Assertions.assertThrows(RuntimeException.class, () -> {
            trafo.transformFileToFields(createQmlContent(new int[]{3,0}), new int[]{2,18});
        });

        assertTrue(
                ex.getMessage().contains("3.0"),
                "Errror message is expected to contain the given version number"
        );
    }


    @Test
    public void uploadQmlOnly_Exception_TooYongMinorVersion(){

        StyleStorageBean trafo = new StyleStorageBean();

        Exception ex = Assertions.assertThrows(RuntimeException.class, () -> {
            trafo.transformFileToFields(createQmlContent(new int[]{2,19}), new int[]{2,18});
        });

        assertTrue(
                ex.getMessage().contains("2.19"),
                "Errror message is expected to contain the given version number"
        );
    }

    @Test
    public void uploadZip_Success(){
        StyleStorageBean trafo = new StyleStorageBean();
        StyleDbContent dbContent = trafo.transformFileToFields(
                createZipContent(new String[]{"fuu.png", "bar.qml", "buz.png"}, 100),
                new int[]{2,18}
        );

        assertTrue(
                dbContent.getQmlContent().contains("<qgis"),
                "db qml content must contain therm '<qgis'"
        );

        assertTrue(
                dbContent.getAssetsContent().isPresent(),
                "Assets must be present"
        );
    }

    @Test
    public void uploadZip_NoQml_Exception(){

        StyleStorageBean trafo = new StyleStorageBean();

        Assertions.assertThrows(RuntimeException.class, () -> {
            trafo.transformFileToFields(
                    createZipContent(new String[]{"fuu.png", "bar.png", "buz.png"}, 100),
                    new int[]{2,18});
        });
    }

    @Test
    public void uploadZip_NoAssets_Exception(){

        StyleStorageBean trafo = new StyleStorageBean();

        Assertions.assertThrows(RuntimeException.class, () -> {
            trafo.transformFileToFields(
                    createZipContent(new String[]{"fuu.qml"}, 100),
                    new int[]{2,18});
        });
    }



    private StyleFileContent createQmlContent(int[] version){

        String fakeQml = MessageFormat.format(
                "<!DOCTYPE qgis PUBLIC \"http://mrcc.com/qgis.dtd\" \"SYSTEM\"><qgis version=\"{0}.{1}.17\"></qgis>",
                version[0],
                version[1]);

        return new StyleFileContent(
                fakeQml.getBytes(),
                StyleStorageBean.FileContentType.QML
                );
    }

    /**
     * Creates a zip file content with the given full file names (path and name).
     * maxAssetSize is the maximum size of the randomly generated byte[] of one asset
     */
    private StyleFileContent createZipContent(String[] fileNamesWithPaths, int maxAssetSize){

        byte[] zipBytes = null;
        boolean qmlIncluded = false;

        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ZipOutputStream zipOut = new ZipOutputStream(bos);

        Random random = new Random();

        try {
            for (String fileName : fileNamesWithPaths) {
                ZipEntry zipEntry = new ZipEntry(fileName);
                zipOut.putNextEntry(zipEntry);

                byte[] bytes = null;
                if(fileName.endsWith("qml")) {
                    bytes = createQmlContent(new int[]{2, 18}).getData();
                    qmlIncluded = true;
                }
                else {
                    bytes = new byte[random.nextInt(maxAssetSize)];
                }

                zipOut.write(bytes);
            }

            zipOut.close();

            zipBytes = bos.toByteArray();
        }
        catch (IOException ioe){
            throw new RuntimeException(ioe);
        }

        if(!qmlIncluded)
            throw new IllegalArgumentException("One of the given file names must be the qml file");

        return new StyleFileContent(zipBytes, StyleStorageBean.FileContentType.ZIP);
    }
}

/*
Funktionen des Beans
* Tuple<String, Optional<String>> styleFileToStorage(File uploadedFile, String qmlVersion)
* File storageToStyleFile(String qml, String assets)
* String styleStorageInfo(String qml, String assets)

Tests:

* download ohne assets --> xy.qml
* download mit assets --> valides zip
* grosses qml mit vielenAssets --> OK

```json
{
	"assets": [{
			"blubb.png": "asdfölasdfjk"
		},
		{
			"blubb.png": "asdfölasdfjk"
		}
	]
}
```
 */
